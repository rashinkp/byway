import {
  ISendMessageUseCase,
  SendMessageInput,
} from "../interfaces/send-message.usecase.interface";
import { IChatRepository } from "../../../repositories/chat.repository.interface";
import { IMessageRepository } from "../../../repositories/message.repository.interface";
import { ChatId } from "../../../../domain/value-object/ChatId";
import { UserId } from "../../../../domain/value-object/UserId";
import { MessageContent } from "../../../../domain/value-object/MessageContent";
import { Message } from "../../../../domain/entities/message.entity";
import { MessageId } from "../../../../domain/value-object/MessageId";
import { Timestamp } from "../../../../domain/value-object/Timestamp";
import { MessageResponseDTO } from "../../..//dtos/chat.dto";
import { Chat } from "../../../../domain/entities/chat.entity";
import { MessageType } from "../../../../domain/enum/Message-type.enum";

export class SendMessageUseCase implements ISendMessageUseCase {
  constructor(
    private readonly chatRepository: IChatRepository,
    private readonly messageRepository: IMessageRepository
  ) {}

  async execute(input: SendMessageInput): Promise<MessageResponseDTO> {
    let chatId: ChatId;
    if (input.chatId) {
      chatId = new ChatId(input.chatId);
    } else if (input.userId) {
      const senderId = new UserId(input.senderId);
      const recipientId = new UserId(input.userId);
      let chat = await this.chatRepository.getChatBetweenUsers(
        senderId,
        recipientId
      );
      if (!chat) {
        chat = await this.chatRepository.create(
          new Chat(
            undefined as any, // id will be generated by Prisma
            senderId,
            recipientId,
            new Timestamp(new Date()),
            new Timestamp(new Date()),
            []
          )
        );
        if (!chat) {
          throw new Error("Failed to create chat");
        }
      }
      chatId = chat.id;
    } else {
      throw new Error("Either chatId or userId must be provided");
    }
    // Determine message type
    let messageType: MessageType;
    if (input.imageUrl) {
      messageType = MessageType.IMAGE;
    } else if (input.audioUrl) {
      messageType = MessageType.AUDIO;
    } else {
      messageType = MessageType.TEXT;
    }
    const message = new Message(
      new MessageId(Math.random().toString(36).substring(2, 15)),
      chatId,
      new UserId(input.senderId),
      input.content ? new MessageContent(input.content) : null,
      input.imageUrl || null,
      input.audioUrl || null,
      messageType,
      false, // isRead
      new Timestamp(new Date())
    );
    try {
      await this.messageRepository.create(message);
    } catch {
      throw new Error("Failed to create message");
    }
    if (chatId && (input.chatId || input.userId)) {
      let chat = input.chatId
        ? await this.chatRepository.findById(chatId)
        : null;
      if (!chat) {
        chat = await this.chatRepository.getChatBetweenUsers(
          new UserId(input.senderId),
          new UserId(input.userId!)
        );
      }
      if (chat) {
        const updatedChat = new Chat(
          chat.id,
          chat.user1Id,
          chat.user2Id,
          chat.createdAt,
          new Timestamp(new Date()),
          chat.messages
        );
        await this.chatRepository.save(updatedChat);
      }
    }
    let enrichedMessage: any = null;
    try {
      enrichedMessage = await this.messageRepository.findByIdWithUserData(
        message.id
      );
    } catch {
      // Optionally handle error, but no log needed
    }
    if (!enrichedMessage) {
      return {
        id: message.id.value,
        chatId: message.chatId.value,
        senderId: message.senderId.value,
        receiverId: input.userId || "",
        content: message.content?.value || "",
        imageUrl: message.imageUrl ? String(message.imageUrl) : undefined,
        audioUrl: message.audioUrl ? String(message.audioUrl) : undefined,
        isRead: false,
        timestamp: message.createdAt.value
          ? new Date(message.createdAt.value).toISOString()
          : "",
      };
    }
    const chat = await this.chatRepository.findById(chatId);
    if (!chat) {
      return {
        id: enrichedMessage.id,
        chatId: enrichedMessage.chatId,
        senderId: enrichedMessage.senderId,
        receiverId: input.userId || "",
        content: enrichedMessage.content || "",
        imageUrl: enrichedMessage.imageUrl || undefined,
        audioUrl: enrichedMessage.audioUrl || undefined,
        isRead: false,
        timestamp: enrichedMessage.createdAt
          ? new Date(enrichedMessage.createdAt).toISOString()
          : "",
      };
    }
    const receiverId =
      chat.user1Id.value === enrichedMessage.senderId
        ? chat.user2Id.value
        : chat.user1Id.value;

    return {
      id: enrichedMessage.id,
      chatId: enrichedMessage.chatId,
      senderId: enrichedMessage.senderId,
      receiverId,
      content: enrichedMessage.content || "",
      imageUrl: enrichedMessage.imageUrl || undefined,
      audioUrl: enrichedMessage.audioUrl || undefined,
      isRead: false,
      timestamp: enrichedMessage.createdAt
        ? new Date(enrichedMessage.createdAt).toISOString()
        : "",
    };
  }
}
