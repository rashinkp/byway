import { ISendMessageUseCase, SendMessageInput } from '../interfaces/send-message.usecase.interface';
import { IChatRepository } from '../../../repositories/chat.repository.interface';
import { IMessageRepository } from '../../../repositories/message.repository.interface';
import { ChatId } from '../../../../domain/value-object/ChatId';
import { UserId } from '../../../../domain/value-object/UserId';
import { MessageContent } from '../../../../domain/value-object/MessageContent';
import { Message } from '../../../../domain/entities/Message';
import { MessageId } from '../../../../domain/value-object/MessageId';
import { Timestamp } from '../../../../domain/value-object/Timestamp';
import { MessageResponseDTO } from '@/domain/dtos/chat.dto';
import { Chat } from '../../../../domain/entities/Chat';
import { MessageType } from '../../../../domain/enum/Message-type.enum';

export class SendMessageUseCase implements ISendMessageUseCase {
  constructor(
    private readonly chatRepository: IChatRepository,
    private readonly messageRepository: IMessageRepository
  ) {}

  async execute(input: SendMessageInput): Promise<MessageResponseDTO> {
    let chatId: ChatId;
    if (input.chatId) {
      chatId = new ChatId(input.chatId);
    } else if (input.userId) {
      const senderId = new UserId(input.senderId);
      const recipientId = new UserId(input.userId);
      let chat = await this.chatRepository.getChatBetweenUsers(senderId, recipientId);
      if (!chat) {
        chat = await this.chatRepository.create(
          new Chat(
            undefined as any, // id will be generated by Prisma
            senderId,
            recipientId,
            new Timestamp(new Date()),
            new Timestamp(new Date()),
            []
          )
        );
        if (!chat) {
          throw new Error('Failed to create chat');
        }
      }
      chatId = chat.id;
    } else {
      throw new Error('Either chatId or userId must be provided');
    }
    // Determine message type
    let messageType: MessageType;
    if (input.imageUrl) {
      messageType = MessageType.IMAGE;
    } else if (input.audioUrl) {
      messageType = MessageType.AUDIO;
    } else {
      messageType = MessageType.TEXT;
    }
    const message = new Message(
      new MessageId(Math.random().toString(36).substring(2, 15)),
      chatId,
      new UserId(input.senderId),
      input.content ? new MessageContent(input.content) : null,
      input.imageUrl || null,
      input.audioUrl || null,
      messageType,
      false, // isRead
      new Timestamp(new Date())
    );
    try {
      await this.messageRepository.create(message);
    } catch {
      throw new Error('Failed to create message');
    }
    if (chatId && (input.chatId || input.userId)) {
      let chat = input.chatId ? await this.chatRepository.findById(chatId) : null;
      if (!chat) {
        chat = await this.chatRepository.getChatBetweenUsers(new UserId(input.senderId), new UserId(input.userId!));
      }
      if (chat) {
        const updatedChat = new Chat(
          chat.id,
          chat.user1Id,
          chat.user2Id,
          chat.createdAt,
          new Timestamp(new Date()),
          chat.messages
        );
        await this.chatRepository.save(updatedChat);
      }
    }
    let enrichedMessage: any = null;
    try {
      enrichedMessage = await this.messageRepository.findByIdWithUserData(message.id);
    } catch {
      // Optionally handle error, but no log needed
    }
    if (!enrichedMessage) {
      return {
        id: message.id.value,
        chatId: message.chatId.value,
        senderId: message.senderId.value,
        receiverId: input.userId || '',
        content: message.content?.value || '',
        imageUrl: message.imageUrl ? String(message.imageUrl) : undefined,
        audioUrl: message.audioUrl ? String(message.audioUrl) : undefined,
        isRead: false,
        timestamp: message.createdAt.value ? new Date(message.createdAt.value).toISOString() : '',
      };
    }
    const chat = await this.chatRepository.findById(chatId);
    if (!chat) {
      return {
        id: enrichedMessage.id,
        chatId: enrichedMessage.chatId,
        senderId: enrichedMessage.senderId,
        receiverId: input.userId || '',
        content: enrichedMessage.content || '',
        imageUrl: enrichedMessage.imageUrl || undefined,
        audioUrl: enrichedMessage.audioUrl || undefined,
        isRead: false,
        timestamp: enrichedMessage.createdAt ? new Date(enrichedMessage.createdAt).toISOString() : '',
      };
    }
    const receiverId = chat.user1Id.value === enrichedMessage.senderId ? chat.user2Id.value : chat.user1Id.value;
    
    return {
      id: enrichedMessage.id,
      chatId: enrichedMessage.chatId,
      senderId: enrichedMessage.senderId,
      receiverId,
      content: enrichedMessage.content || '',
      imageUrl: enrichedMessage.imageUrl || undefined,
      audioUrl: enrichedMessage.audioUrl || undefined,
      isRead: false,
      timestamp: enrichedMessage.createdAt ? new Date(enrichedMessage.createdAt).toISOString() : '',
    };
  }
} 