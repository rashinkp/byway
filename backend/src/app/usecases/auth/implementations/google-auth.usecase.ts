import { IAuthRepository } from "../../../repositories/auth.repository";
import { UserMapper } from "../../../mappers/user.mapper";
import { IGoogleAuthUseCase } from "../interfaces/google-auth.usecase.interface";
import { Role } from "../../../../domain/enum/role.enum";
import { AuthProvider } from "../../../../domain/enum/auth-provider.enum";
import { Email } from "../../../../domain/value-object/email";
import { GoogleAuthGateway, GoogleUserInfo } from "../../../providers/I.google-auth.provider";
import { HttpError } from "../../../../presentation/http/errors/http-error";
import { User } from "../../../../domain/entities/user.entity";

export class GoogleAuthUseCase implements IGoogleAuthUseCase {
  constructor(
    private authRepository: IAuthRepository,
    private googleAuthGateway: GoogleAuthGateway
  ) {}

  async execute(accessToken: string): Promise<User> {
    try {
      let googleUser: GoogleUserInfo;
      try {
        googleUser = await this.googleAuthGateway.getUserInfo(accessToken);
      } catch {
        throw new HttpError("Invalid Google access token", 401);
      }

      // Get existing user record if any
      const existingUserRecord = await this.authRepository.findUserByEmail(googleUser.email);

      if (!existingUserRecord) {
        // Create new user domain entity
        const email = new Email(googleUser.email);
        const user = new User({
          id: "", // Will be generated by database
          name: googleUser.name,
          email: email,
          googleId: googleUser.googleId,
          role: Role.USER,
          authProvider: AuthProvider.GOOGLE,
          isVerified: true, // Google users are verified by default
          avatar: googleUser.picture,
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        // Save to repository and get back the record with ID
        const userRecord = await this.authRepository.createUser(user);
        return UserMapper.toDomain(userRecord);
      }

      // Update existing user
      const existingUser = UserMapper.toDomain(existingUserRecord);
      
      // Update user properties
      if (googleUser.googleId) {
        existingUser.updateProfile({ 
          name: googleUser.name !== existingUser.name ? googleUser.name : undefined,
          avatar: googleUser.picture
        });
        // Note: We'd need to add a method to update googleId in the domain entity
        // For now, we'll create a new updated entity
      }
      
      existingUser.verifyEmail(); // Ensure user is verified
      
      // Save updated user
      const userRecord = await this.authRepository.updateUser(existingUser);
      return UserMapper.toDomain(userRecord);
    } catch (error) {
      if (error instanceof HttpError) {
        throw error;
      }
      if (error instanceof Error) {
        throw new HttpError(error.message, 400);
      }
      throw new HttpError("Failed to process Google authentication", 500);
    }
  }
}
