import { User } from "../../../../domain/entities/user.entity";
import { IAuthRepository } from "../../../repositories/auth.repository";
import { HttpError } from "../../../../presentation/http/errors/http-error";
import * as bcrypt from "bcrypt";
import { IRegisterUseCase } from "../interfaces/register.usecase.interface";
import { OtpProvider } from "../../../../infra/providers/otp/otp.provider";
import { RegisterRequestDto } from "../../../dtos/auth.dto";
import { AuthProvider } from "../../../../domain/enum/auth-provider.enum";
import { Email } from "../../../../domain/value-object/email";
import { Role } from "@/domain/enum/role.enum";

export class RegisterUseCase implements IRegisterUseCase {
  constructor(
    private authRepository: IAuthRepository,
    private otpProvider: OtpProvider
  ) {}

  async execute(dto: RegisterRequestDto): Promise<User> {
    let user = await this.authRepository.findUserByEmail(dto.email);

    try {
      if (user && user.isVerified) {
        throw new HttpError("Email already exists and is verified", 409);
      }

      if (!dto.password) {
        throw new HttpError("Password is required", 400);
      }
      const hashedPassword = await bcrypt.hash(dto.password, 10);

      if (!user) {
        // Create new user using constructor
        const email = new Email(dto.email);
        user = new User({
          id: "", // Will be generated by database
          name: dto.name,
          email: email,
          password: hashedPassword,
          role: Role.USER,
          authProvider: AuthProvider.EMAIL_PASSWORD,
          isVerified: false,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        user = await this.authRepository.createUser(user);
      } else {
        // Update existing unverified user using domain methods
        user.updateProfile({ name: dto.name });
        user.changePassword(hashedPassword);
        user = await this.authRepository.updateUser(user);
      }

      await this.otpProvider.generateOtp(user.email.address, user.id);
      // TODO: Implement email sending
      // await this.emailProvider.sendOtpEmail(user.email.address, verification.otp);

      return user;
    } catch (error) {
      if (error instanceof HttpError) {
        throw error;
      }
      if (error instanceof Error) {
        throw new HttpError(error.message, 400);
      }
      throw new HttpError("Registration failed", 500);
    }
  }
}
