import { User } from "../../../../domain/entities/user.entity";
import { IAuthRepository } from "../../../repositories/auth.repository";
import { UserMapper } from "../../../mappers/user.mapper";
import { HttpError } from "../../../../presentation/http/errors/http-error";
import { IRegisterUseCase } from "../interfaces/register.usecase.interface";
import { OtpProvider } from "../../../../infra/providers/otp/otp.provider";
import { RegisterRequestDto } from "../../../dtos/auth.dto";
import { AuthProvider } from "../../../../domain/enum/auth-provider.enum";
import { Email } from "../../../../domain/value-object/email";
import { Role } from "../../../../domain/enum/role.enum";
import * as bcrypt from "bcrypt";

export class RegisterUseCase implements IRegisterUseCase {
  constructor(
    private authRepository: IAuthRepository,
    private otpProvider: OtpProvider
  ) {}

  async execute(dto: RegisterRequestDto): Promise<User> {
    try {
      // Get existing user record if any
      const existingUserRecord = await this.authRepository.findUserByEmail(dto.email);
      
      if (existingUserRecord) {
        const existingUser = UserMapper.toDomain(existingUserRecord);
        if (existingUser.isVerified) {
          throw new HttpError("Email already exists and is verified", 409);
        }
      }

      if (!dto.password) {
        throw new HttpError("Password is required", 400);
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(dto.password, 10);

      let user: User;
      if (!existingUserRecord) {
        // Create new user domain entity
        const email = new Email(dto.email);
        user = new User({
          id: "", // Will be generated by database
          name: dto.name,
          email: email,
          password: hashedPassword,
          role: Role.USER,
          authProvider: AuthProvider.EMAIL_PASSWORD,
          isVerified: false,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        
        // Save to repository and get back the record with ID
        const userRecord = await this.authRepository.createUser(user);
        user = UserMapper.toDomain(userRecord);
      } else {
        // Update existing unverified user using domain methods
        const existingUser = UserMapper.toDomain(existingUserRecord);
        existingUser.updateProfile({ name: dto.name });
        existingUser.changePassword(hashedPassword);
        
        // Save updated user
        const userRecord = await this.authRepository.updateUser(existingUser);
        user = UserMapper.toDomain(userRecord);
      }

      // Generate OTP for verification
      await this.otpProvider.generateOtp(user.email.address, user.id);
      // TODO: Implement email sending
      // await this.emailProvider.sendOtpEmail(user.email.address, verification.otp);

      return user;
    } catch (error) {
      if (error instanceof HttpError) {
        throw error;
      }
      if (error instanceof Error) {
        throw new HttpError(error.message, 400);
      }
      throw new HttpError("Registration failed", 500);
    }
  }
}
